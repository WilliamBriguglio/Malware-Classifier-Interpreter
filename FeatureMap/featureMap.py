import re
import sys

def findNGram(bytes, nGram, nGramSize=6, lineLength=16):
    l = lineLength #length in bytes of a line in the .bytes file
    n = nGramSize #length in bytes of the ngram

    #check inputs
    assert (n <= l),"ERROR: Line Length must be >= byte gram length"
    assert (len(nGram) == n*2),"ERROR: length of nGram != value specified in nGramSize"

    #Separate nGram into list of bytes
    gramBytes = []
    for i in range(0, 2*n, 2):
        gramBytes.append(nGram[0+i:2+i])

    #matches a single space OR a newline->address->space sequence, in which case the address is captured
    nonByte = r'\s([0-9A-F]{8}\s)?' 

    #matches the nGram weather it appears across 2 lines or not 
    address = nonByte.join(gramBytes)

    #matches from the start of line till the beginning of the nGram while capturing the address which appears at the start of said line ONLY if the ngram appears wholly on one line
    #otherwise the address appearing withing the ngram is captured by nonByte
    preamble = r'(([0-9A-F]{8}\s)(?:[0-9A-F][0-9A-F]\s){,' + str(l-n) + r'})?'
    

    nGramRegEx = preamble + address #matches the nGram if it appears split between lines, in which case it captures the address spliting the nGram OR
                                    #matches the nGram if it is wholly on one line, as well as everything on that line before the nGram, while capturing the address
    
    match = re.findall(nGramRegEx, bytes) #finds all occurances of nGram in Bytes while capturing the nearest address

    if match:
        return match
    else:
        return 0


def findCodeSnips(addrs, asm, padding=3, nGramSize=6, addrLength=8):

    asm = ((padding + 1) * "\n") + asm + ((padding + 1) * "\n")#add \n's to beginning and end of .asm file so regex can handle code appearing on the edge of .asm files 

    #store snippets of code for each row/ocruane of nGram
    codeSnippets = []

    #for each address in list of address where ngram was found
    for row in addrs:

       
        intAddr = 0 #integer address of the first byte of the byte gram's occurance in the .bytes file

        if row[0] != "":#if row[0] != "", then the ngram appeared on one line in .bytes, and the captured address at row[1] is the Addr of that line while row[0] is the Addr of that line and the bytes between the start of the line and the start of the ngram
            intAddr = int(row[1], 16) + (len(row[0].split()) - 1) #adjust the Addr in row[1] to account for the bytes between the start of the line and the start of the ngram 

        else: #otherwise, the captured Addr was contained within the ngram since it was split between two lines in the .bytes file, so we must adjust to find the correct Addr
            for i in range(len(row)):
                #for k bytes appearing in the first line, and before the captured Addr, there is k-1 empty captures in row
                if row[i] != "": #if the captured Addr appears at row[i]
                    intAddr = int(row[i], 16) - (i-1) #the correct intAddr is i-1 bytes prior to the captured Addr
                    break

        #list of potential line addresses in .asm file for the ngram (including the initAddr, there are nGramSize addresses that might appear in the .asm file since the nGram may not appear at the beginning of the line and may be split across two lines)
        potentialAddrs = []
        offset = 0
        while(offset < nGramSize):
            straddr = str(hex((intAddr + offset)))[2:].upper() 
            potentialAddrs.append("0" * (addrLength-len(straddr)) + straddr)
            offset+=1
        # Must find ALL lines with these addreses (in potentialAddrs), then print padding before and padding after



        snippet = "" #will hold the total code snippet for this row in addrs
        lastMatch = "" #holds the most recent match, used later to find the padding after the ngram

        print("PAs: ",potentialAddrs)

        s = 1 #being set to 1 indicates we are looking for the start of ngram and its preceeding padding
        m = 0 #being set to 0 indicates we haven't found the start of the ngram
        nf = 0 #flag indicating part of the ngram is on the line before the first found potential address
        for i in potentialAddrs:

            if m == 1:
                searchReg = r"\.[A-Za-z]+:" +i+ r".*\n"
                match = re.search(searchReg, asm)
                if match:
                    snippet += lastMatch
                    lastMatch = match.group()

            if s == 1: #if looking for start of 6-gram (i.e. first potential address not matched)

                #(".*\n" * padding)         grab [padding] lines before the first line containing part of the ngram. 
                #(nf * ".*\n")              grab 1 line of padding extra if part of the ngram is found on the line before the first matched address
                #"\.[A-Za-z]+:" +i+ ".*\n   matching the line with the address i
                searchReg = (r".*\n" * padding) + (nf * r".*\n") + r"\.[A-Za-z]+:" +i+ r".*\n"
                
                nf = 1 #if first potential address is not found, then set nf flag if not already set
                match = re.search(searchReg, asm) 
                if match:
                    snippet += match.group()
                    s = 0 #being set to 0 indicates the start of the n-gram and padding before ngram were found
                    m = 1 #indicates we are now looking for lines which contain the rest of the ngram

        if snippet != "": #if code snippit found #add the last line and remaining padding
            searchReg = re.escape(lastMatch) + r".*\n.*\n.*\n"
            match = re.search(searchReg, asm)
            snippet += match.group()
        else: #if code snippet not found, this indicates the entire ngram does not appear at the beginning of a line, but is on one line so we can search for the address closest to but less then the address of the first ngram
            for i in range(16):
                searchReg = (r".*\n" * padding) + r'\.[A-Za-z]+:'+str(hex(int(potentialAddrs[0], 16) - i))[2:].upper()+r'.*\n' + (r'.*\n' * padding) #grab pre padding, address+line, and post padding
                match = re.search(searchReg, asm)
                if match:
                    snippet += match.group()
            return -1 #if still not found, return error signal

        #add code snippet for current row to list of snippets
        codeSnippets.append(snippet)

    return codeSnippets

def main():
    print("\n\n")

    sampleID = "4WM7aZDLCmlosUBiqKOx" #ID of sample (assumed .asm file and .bytes file have the naming format: <sampleID>.bytes and <sampleID>.asm)
    nGram = "D0506A00E8B8" #nGram to find code snippet for in .asm file
    ByteGramLength = int(len(nGram)/2)
    lineLength = 16 #bytes per line in the .bytes file (program assumes same line length per line)
    addrLength = 8 #number of digits in the addresses in the .asm file (program assumes the same number of digits for each line)
    padding = 3 #number of lines of code to include before and after the code snippet associated with the nGram

    #read bytes from .bytes file
    fileName = sampleID + ".bytes"
    fp = open(fileName, "r")
    bytes = fp.read()
    fp.close()

    #find addresses of matching byte-grams in .bytes file
    addresses = findNGram(bytes, nGram, nGramSize=ByteGramLength, lineLength=lineLength)
    if addresses == 0:
        print("no provided nGram not found in provided .bytes file")
        return 1

    print(addresses)

    #load .asm file
    fileName = sampleID + ".asm"
    fp = open(fileName, "r", errors='replace')
    asm = fp.read()
    fp.close()

    #find code snippets corresponding to provided nGram
    codeSnips = findCodeSnips(addresses, asm, padding=padding, nGramSize=ByteGramLength, addrLength=addrLength) 

    #print code Snips
    for i in codeSnips:
        print("\n\n")
        print(i)
        

    return 0

print("\nMain exited with code: "+str(main())+"\n\n")