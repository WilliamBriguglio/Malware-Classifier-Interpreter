import re
import sys
import copy

def findNGram(bytes, nGram, nGramSize=6, lineLength=16):
    l = lineLength #length in bytes of a line in the .bytes file
    n = nGramSize #length in bytes of the ngram

    #check inputs
    assert (n <= l),"ERROR: Line Length must be >= byte gram length"
    assert (len(nGram) == n*2),"ERROR: length of nGram != value specified in nGramSize"

    #Separate nGram into list of bytes
    gramBytes = []
    for i in range(0, 2*n, 2):
        gramBytes.append(nGram[0+i:2+i])

    #matches a single space OR a newline->address->space sequence, in which case the address is captured
    nonByte = r'\s([0-9A-F]{8}\s)?' 

    #matches the nGram weather it appears across 2 lines or not 
    address = nonByte.join(gramBytes)

    #matches from the start of line till the beginning of the nGram while capturing the address which appears at the start of said line ONLY if the ngram appears wholly on one line
    #otherwise the address appearing withing the ngram is captured by nonByte
    preamble = r'(([0-9A-F]{8}\s)(?:[0-9A-F][0-9A-F]\s){,' + str(l-n) + r'})?'
    

    nGramRegEx = preamble + address #matches the nGram if it appears split between lines, in which case it captures the address spliting the nGram OR
                                    #matches the nGram if it is wholly on one line, as well as everything on that line before the nGram, while capturing the address
    
    match = re.findall(nGramRegEx, bytes) #finds all occurances of nGram in Bytes while capturing the nearest address

    if match:
        return match
    else:
        return -1

def removeDups(asm, potentialAddrs):

    asm2 = copy.deepcopy(asm) #make copy of .asm bytes
    sections = [] #holds the section information which is removed when lines are combined

    for i in range(len(potentialAddrs)):
        rep = r"\n\.[A-Za-z]+:"+potentialAddrs[i]
        try: #match the i-th potential address
            sections.append(re.search(r"\n\.([A-Za-z]+):"+potentialAddrs[i], asm2).groups()[0]) #captures the section data such as "text" or "rdata" so it can be added back later
        except:
            sections.append("")
        asm2 =  re.sub(rep,">>>"+str(i)+"<<<", asm2) #replace with standin >>>[i]<<<, where i indicates the i-th potential address
        asm2 =  re.sub(r'>>>'+str(i)+r'<<<' ,"\n."+sections[i]+":"+potentialAddrs[i], asm2, count=1) #replace only the first standin with the original address, so all lines corresponding to that address can be found later

    return asm2, sections

    
def replaceDups(snippet, potentialAddrs, sections):
    
    for i in range(len(potentialAddrs)):
        snippet =  re.sub(r'>>>'+str(i)+r'<<<' ,"\n."+sections[i]+":"+potentialAddrs[i], snippet) #replace the i-th standin with the i-th potential address and its section data
    
    return snippet

def findCodeSnips(addrs, asm, padding=3, nGramSize=6, addrLength=8):

    asm = ((padding + 1) * "\n") + asm + ((padding + 1) * "\n")#add \n's to beginning and end of .asm file so regex can handle code appearing on the edge of .asm files 

    #store snippets of code for each row/ocruane of nGram
    codeSnippets = []

    #for each address in list of address where ngram was found
    for row in addrs:
       
        intAddr = 0 #integer address of the first byte of the byte gram's occurance in the .bytes file

        if row[0] != "":#if row[0] != "", then the ngram appeared on one line in .bytes, and the captured address at row[1] is the Addr of that line while row[0] is the Addr of that line and the bytes between the start of the line and the start of the ngram
            intAddr = int(row[1], 16) + (len(row[0].split()) - 1) #adjust the Addr in row[1] to account for the bytes between the start of the line and the start of the ngram 

        else: #otherwise, the captured Addr was contained within the ngram since it was split between two lines in the .bytes file, so we must adjust to find the correct Addr
            for i in range(len(row)):
                #for k bytes appearing in the first line, and before the captured Addr, there is k-1 empty captures in row
                if row[i] != "": #if the captured Addr appears at row[i]
                    intAddr = int(row[i], 16) - (i-1) #the correct intAddr is i-1 bytes prior to the captured Addr
                    break

        #list of potential line addresses in .asm file for the ngram (including the initAddr, there are nGramSize addresses that might appear in the .asm file since the nGram may not appear at the beginning of the line and may be split across two lines)
        potentialAddrs = []
        offset = 0
        while(offset < nGramSize):
            straddr = str(hex((intAddr + offset)))[2:].upper() 
            potentialAddrs.append("0" * (addrLength-len(straddr)) + straddr)
            offset+=1
        # Must find ALL lines with these addreses (in potentialAddrs), then print padding before and padding after

        asm2, sections = removeDups(asm, potentialAddrs) #lines which have the same address are combined into a single line

        snippet = "" #will hold the total code snippet for this row in addrs
        lastMatch = "" #holds the most recent match, used later to find the padding after the ngram

        s = 1 #being set to 1 indicates we are looking for the start of ngram and its preceeding padding
        m = 0 #being set to 0 indicates we haven't found the start of the ngram
        nf = 0 #flag indicating part of the ngram is on the line before the first found potential address
        for i in potentialAddrs:

            if m == 1:
                searchReg = r"\.[A-Za-z]+:" +i+ r".*\n"
                match = re.search(searchReg, asm2)
                if match:
                    snippet += lastMatch
                    lastMatch = match.group()

            if s == 1: #if looking for start of 6-gram

                #(".*\n" * padding)         grab [padding] lines before the first line containing part of the ngram. 
                #(nf * ".*\n")              grab 1 line of padding extra if part of the ngram is found on the line before the first matched address
                #"\.[A-Za-z]+:" +i+ ".*\n   matching the line with the address i
                searchReg = (r".*\n" * padding) + (nf * r".*\n") + r"\.[A-Za-z]+:" +i+ r".*\n"
                
                nf = 1 #if first potential address is not found, then set nf flag if not already set
                match = re.search(searchReg, asm2) 
                if match:
                    snippet += match.group()
                    s = 0 #being set to 0 indicates the start of the n-gram and padding before ngram were found
                    m = 1 #indicates we are now looking for lines which contain the rest of the ngram

        if snippet != "": #if code snippit found #add the last line and remaining padding
            if lastMatch != "": #if last match is set, then more lines containing the nGram were found, the last of which is in last match
                searchReg = re.escape(lastMatch) + (r'.*\n' * padding) #add the last match plus the next padding lines to the snippet
                match = re.search(searchReg, asm2)
                snippet += match.group()
            else: #if it isnt set, then the entire ngram was contained in the two lines plus padding matched when s equaled 1
                searchReg = snippet.split("\n")[-2] + (r'.*\n' * (padding + 1)) #search for last line of what is already in snippet, plus padding more lines
                match = re.search(searchReg, asm2)
                snippet += "\n".join(match.group().split("\n")[1:]) #only add the paddong morelines to snippet
        else: #if code snippet not found, this indicates the entire ngram does not appear at the beginning of a line, but is on one line so we can search for the address closest to but less then the address of the first ngram
            for i in range(16):
                searchReg = (r".*\n" * padding) + r'\.[A-Za-z]+:'+str(hex(int(potentialAddrs[0], 16) - i))[2:].upper()+r'.*\n' + (r'.*\n' * padding) #grab pre padding, address+line, and post padding
                match = re.search(searchReg, asm2)
                if match:
                    snippet += match.group()

        #if code snippet found for current row, add to list of snippets
        if snippet != "":    
            snippet = replaceDups(snippet, potentialAddrs, sections) #replace substitutions made earlier with their original data
            codeSnippets.append(snippet)

    if codeSnippets:
        return codeSnippets
    else:
        return -1

def main():
    print("\n\n")

    sampleID = "4WM7aZDLCmlosUBiqKOx" #ID of sample (assumed .asm file and .bytes file have the naming format: <sampleID>.bytes and <sampleID>.asm)
    nGram = "D0506A00E8B8" #nGram to find code snippet for in .asm file

    ByteGramLength = int(len(nGram)/2) #length of the nGram
    lineLength = 16 #bytes per line in the .bytes file (program assumes same line length per line)
    addrLength = 8 #number of digits in the addresses in the .asm file (program assumes the same number of digits for each line)
    padding = 3 #number of lines of code to include before and after the code snippet associated with the nGram

    #read bytes from .bytes file
    fileName = sampleID + ".bytes"
    fp = open(fileName, "r")
    bytes = fp.read()
    fp.close()

    #find addresses of matching byte-grams in .bytes file
    addresses = findNGram(bytes, nGram, nGramSize=ByteGramLength, lineLength=lineLength)
    if addresses == -1:
        print("Error: provided nGram not found in provided .bytes file")
        return -1

    #load .asm file
    fileName = sampleID + ".asm"
    fp = open(fileName, "r", errors='replace')
    asm = fp.read()
    fp.close()

    #find code snippets corresponding to provided nGram
    codeSnips = findCodeSnips(addresses, asm, padding=padding, nGramSize=ByteGramLength, addrLength=addrLength) 

    #print code Snips
    if codeSnips == -1:
        print("Error: nGram found in .byte file but corresponding code cannot be found in .asm file")
        return -2
    for i in codeSnips:
        print("\n\n")
        print(i)
        

    return 0

print("\nMain exited with code: "+str(main())+"\n\n")